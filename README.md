pythonでDPマッチングを行い、アライメントを推定したり簡単な発話認識をする。

【事前準備】
"02dp_matching"というフォルダを"data"や"00prepare"フォルダと同じ階層に作成し、その中でソースコードの作成と実行をしていく。

【実行手順】
”00_prepare_wav_dp.py”⇨”01_compute_mfcc dp.py”⇨”02_dp_matching.py”⇨”03_dtw_spectrogram.py”⇨”04_dp_matching_knn.py”

【コード解説】
”００_prepare_wav_dp.py”
音声を16,000Hzにダウンサンプリングするコード。


"01_compute_mfcc dp.py"
ダウンサンプリングした音声ファイルについて、データの準備段階でも使用した”01_compute_mfcc.py”により、MFCC特徴量を抽出する。


”02_dp_matching.py”
二つの音声のMFCC特徴量系列に対してDPマッチングを行い、アライメントを推定するソースコード。


DPマッチングを行う処理は”dp_matching”の関数内で実装している。”dp_matching”の入力は２個の特徴量系列で、特徴量は［フレーム数×次元数］の配列である。
出力は、最短経路における累積コスト”total_cost”と、最短経路（アライメント）”min_path”になる。
関数内では、最初に距離行列”distance”を計算する。ただし、ユークリッド距離の代わりに、平方根計算を省略したユークリッド距離の二乗を用いている。
そして各マスにおける累積コストを計算して”cost”に格納していく。この時後でバックトラックをするために、選択したパス（０：縦の遷移、１：斜めの遷移、２：横の遷移）を”track”に記録する。
各ますの最短距離を計算した後、最終マスのコストに対して総フレーム数で正規化した値を”total_cost”とする。その後バックトラックを行う。
最終マスから”track”の値を逆に辿っていき、辿ったフレーム番号を”min_path”に記録していく。最初のマスに到達した後、”min_path[::-1]”として逆順に並べ替えることで、
ゴールからの経路をスタートからの経路に変換している。あとは、得られたアライメント”min_path”を”./alignment.txt”に書き込んで終了する。


”03_dtw_spectrogram.py”
出力された”alighment.txt”のアライメント情報を使って、音声のスペクトログラムを引き伸ばして表示するソースコード。


”04_dp_matching_knn.py”
音声認識を行うソースコード。
発話している文章は１０種類×５セットの５０種類。そこで入力された音声が、１０種類のうちのどの文章を話しているのかを当てる認識実験を行う。
仮にセット番号１の音声を入力する場合、セット２〜５の音声（１０種類×４セット＝４０個の音声）をシンプルテンプレートとする。
入力音声に対して、４０個のテンプレートそれぞれのDTW距離を計算し、DTW距離が近かったテンプレートの発話文章が推定結果になるというもの。

入力する音声のセットを”query_set = 1”、発話文章の番号を”query_utt = 9”としている。つまり”mfcc/REPEAT500_set1_009.bin”が、入力特徴量として読み込まれる。
次に、入力されたセット（この場合はセット１）を除く全ての音声ファイルを順番に”target”として読み込み、DPマッチンングによりDTW距離”tmp_cost”を計算する。
その際”target”の発話文章番号”utt_id”、セット番号”set_id”、DTW距離を辞書型の変数”cost”に記録しておく。
全ての音声ファイルに対してDPマッチングを行った後、”cost”をDTW距離の小さい順に並び替える。そしてDTW距離の小さい順に、”target”のランキングを表示している。
最後に、DTW距離の小さい”target”の発話文章番号を最終出力として表示する。
